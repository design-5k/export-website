/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 model.gltf
*/

import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations, Gltf, useHelper } from "@react-three/drei";
import { useFrame, useLoader, useThree, Canvas  } from "@react-three/fiber";
import * as THREE from 'three';
import { AnimationMixer, BoxHelper } from "three";
import MouseSpeed from "mouse-speed";

//Saving window size
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight
};

//Mouse position related stuff
const pointer = new THREE.Vector2;

const cursor = {
  x: 0,
  y: 0,
  relX: 0,
  relY : 0
};

//Mouse speed related vars
var timestamp = null;
var lastMouseX = null;
let speedX = 0;
let calculateSpeed = true;

//calculating and storing mouse positions
window.addEventListener("mousemove", (event) => {
  cursor.x = event.clientX;
  cursor.y = event.clientY;
  cursor.relX = cursor.x - sizes.width/2;
  cursor.relY = sizes.height/2 - cursor.y;

  pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;  

  if(calculateSpeed) {
    if (timestamp === null) {
      timestamp = Date.now();
      lastMouseX = cursor.x
      return;
    }
    var now = Date.now();
    var dt =  now - timestamp;
    var dx = event.clientX - lastMouseX;
    speedX = Math.round(dx / dt * 100);

    timestamp = now;
    lastMouseX = event.clientX;
  } else { speedX = 0; }
});

//Function to map value to a range
function scale(number, inMin, inMax, outMin, outMax) {
  return ((number - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
}

//Initializing animation related variables
const mixer = new THREE.AnimationMixer();
var animIntialised = false;
let clickable = true;
let tonguesout = false;
let hairKicking = false;
let pullingaway = false;
let pullingtowards = false;

//Function to set blend weights to 0 for pointer position related animations
function intialiseMovementActions(action) {
  action.play();
  action.weight = 0;
  action.blendMode = 2500;
}

//Function to add all playable animations to mixer to allow blending
function initAnims(animations, mixer, root) {
  animations.forEach((animation) => {
    mixer.clipAction(animation, root).play();
  })
  animIntialised = true;
  console.log("anims initialised");
}

//For animations that should be played once on trigger
function playActionOnce(action, origAction) {
  origAction.fadeOut(1);
  action.reset();
  action.fadeIn(1);
  action.play();
  action.setLoop(THREE.LoopOnce);  
  action.clampWhenFinished = false;
}

//For animations that should be played on loop on trigger
function playActionLoop(action, origAction) {
  origAction.fadeOut(1);
  action.reset();
  action.fadeIn(1);
  action.play();
  action.setLoop(THREE.LoopRepeat);  
  action.clampWhenFinished = false;
}  

//export function starts here
export default function Model(props) {
  const group = useRef() 

  const { nodes, materials, animations } = useGLTF("/model.gltf");  

  materials.teeth.color = new THREE.Color(0x525252);
  materials.eye.color = new THREE.Color(0xdbdbdb);
  materials['horse-base'].roughness = 0.65;
  materials.braids.roughness = 0.8;

  const { actions } = useAnimations(animations, group)   
  console.log(actions);  

  useFrame((state, delta) => {    

    //Initializing all animations
    if(!animIntialised) {
      actions.default.play();
      initAnims(animations, mixer, actions.default.getRoot());
    } 
    intialiseMovementActions(actions.openmouth);
    intialiseMovementActions(actions.dwayne);
    
    //pony head movement tracked to pointer position
    nodes.Bonehead.rotation.z = scale(cursor.x, 0, sizes.width, -0.5, 0.5) * -1;
    nodes.Bonehead.rotation.x = scale(cursor.y, 0, sizes.width, 2.0, 3.0);

    //On click animation triggers 
    window.addEventListener("click", (event) => {
        if(clickable){
          //interactions for when user clicks on the pony
          if(pointer.x > -0.2 && pointer.x < 0.2) {
            if(pointer.y < -0.5 && pointer.y > -0.8) {
              clickable = false;
              tonguesout = true;
              playActionOnce(actions.tonguepeep, actions.default)
              const clipLen = actions.tonguepeep.getClip().duration*1000;              
              setTimeout(function() { playActionLoop(actions.default, actions.tonguepeep);}, clipLen - 500);
              setTimeout(function() { clickable = true; tonguesout=false; }, clipLen);
            }
            if(pointer.y > -0.5 && pointer.y < 0.35) {
              clickable = false;
              let random = Math.round(Math.random()*10);
              console.log(random);
              
              let actionToDo;
              if(random%2) actionToDo = actions.headbanger;
              else actionToDo = actions.blower;
              playActionOnce(actionToDo, actions.default)
              const clipLen = actionToDo.getClip().duration*1000;              
              setTimeout(function() { playActionLoop(actions.default, actionToDo);}, clipLen - 1000);
              setTimeout(function() { clickable = true; }, clipLen);
            }
            if(pointer.y > 0.36 && pointer.y < 0.7) {
              //hairKick doesnt use clicks anymore
              /*
              clickable = false;
              playActionOnce(actions.hairkick, actions.default)
              const clipLen = actions.hairkick.getClip().duration*1000;              
              setTimeout(function() { playActionLoop(actions.default, actions.hairkick); }, clipLen - 800);
              setTimeout(function() { clickable = true; }, clipLen);*/
            }
          }

          //interaction for click on top-left corner
          if(pointer.x > 0.65 && pointer.y > 0.65) {
              clickable = false;
              tonguesout = true;
              playActionOnce(actions.tounguesout, actions.default)
              const clipLen = actions.tounguesout.getClip().duration*1000;              
              setTimeout(function() { playActionLoop(actions.default, actions.tounguesout); }, clipLen - 1000);
              setTimeout(function() { clickable = true; tonguesout = false; }, clipLen);
          }          

          //interaction for click on top-right corner
          if(pointer.x < -0.8 && pointer.y > 0.8) {
            clickable = false;
            playActionOnce(actions.shakeit, actions.default)
            const clipLen = actions.shakeit.getClip().duration*1000;              
            setTimeout(function() { playActionLoop(actions.default, actions.shakeit); }, clipLen - 1000);
            setTimeout(function() { clickable = true; }, clipLen);
        }  
        }
    }); 
     
    //additional interactions mapped to cursor position
    if(!tonguesout) {
      if(cursor.relX > 0 && cursor.relY > 0) {
        actions.openmouth.weight = scale(Math.min(cursor.relX, cursor.relY), 0, sizes.width/2, 0, 1)  
      } else { actions.openmouth.weight = 0; }
  
      if(cursor.relX < 0 && cursor.relY > 0) {
        actions.dwayne.weight = scale(Math.min((cursor.relX*-1), cursor.relY), 0, sizes.width/2, 0, 1)      
      } else { actions.dwayne.weight = 0; }  
    } 

    //hair kicking interaction
    if(!hairKicking) {
      if(pointer.x > -0.2 && pointer.x < 0.2 && pointer.y > 0.36 && pointer.y < 0.7) {
        clickable = false;
        hairKicking = true;
        playActionOnce(actions.hairkick, actions.default)
        const clipLen = actions.hairkick.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.hairkick); }, clipLen - 800);
        setTimeout(function() { hairKicking = false; clickable = true; }, clipLen);
      }
    }

    //pulling away interaction
    if(!pullingaway && !pullingtowards) {
      if(pointer.x < -0.6 && pointer.y < -0.6) {
        clickable = false;
        pullingaway = true;
        playActionOnce(actions.moveaway, actions.default)
        const clipLen = actions.moveaway.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.moveaway); }, clipLen - 800);
        setTimeout(function() { clickable = true; }, clipLen);
      }
      if(pointer.x > 0.6 && pointer.y < -0.6) {
        clickable = false;
        pullingtowards = true;
        playActionOnce(actions.movetoward, actions.default)
        const clipLen = actions.movetoward.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.movetoward); }, clipLen - 800);
        setTimeout(function() { clickable = true; }, clipLen);
      }
    }

    if (pullingaway && clickable) {
      if(pointer.x > -0.6 || pointer.y > -0.6) pullingaway = false;
    }

    if (pullingtowards && clickable) {
      if(pointer.x < 0.6 || pointer.y > -0.6) pullingtowards = false;
    }

    //interactions mapped to cursor speed 
    if(speedX>3000) {
      calculateSpeed = false;
      playActionOnce(actions.headknock1, actions.default)
      const clipLen = actions.headknock1.getClip().duration*1000;              
      setTimeout(function() { playActionLoop(actions.default, actions.headknock1); }, clipLen - 1000);
      setTimeout(function() { calculateSpeed = true; }, clipLen);
    }   

    mixer.update();
  });  

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" position={[0, -2, -15]} scale={2}>
          <primitive object={nodes.Boneneck} />
          <primitive object={nodes.Bonehead} />
          <skinnedMesh name="eyes" geometry={nodes.eyes.geometry} material={materials.eye} skeleton={nodes.eyes.skeleton} />
          <group name="pony">
            <skinnedMesh name="pony-mesh" geometry={nodes['pony-mesh'].geometry} material={materials['horse-base']} skeleton={nodes['pony-mesh'].skeleton} />
            <skinnedMesh name="pony-mesh_1" geometry={nodes['pony-mesh_1'].geometry} material={materials.braids} skeleton={nodes['pony-mesh_1'].skeleton} />
          </group>
          <skinnedMesh name="teeth" geometry={nodes.teeth.geometry} material={materials.teeth} skeleton={nodes.teeth.skeleton} />
          <skinnedMesh name="tongue" geometry={nodes.tongue.geometry} material={materials.tongue} skeleton={nodes.tongue.skeleton} />
        </group>
        <pointLight name="Point" intensity={0.1} decay={2} position={[4,0,-25]} rotation={[-Math.PI / 2, 0, 0]} />
        <pointLight name="Area002" intensity={0.1} decay={2} position={[-5,0,-30]} rotation={[-1.1, -0.29, -2.08]} scale={5.13} />
        <pointLight name="Area001" intensity={0.1} decay={2} position={[0,20,-15]} rotation={[-3.13, -0.54, -3.14]} scale={5.13} />
        <pointLight name="Area" intensity={0} decay={2} position={[1.08, 3.17, -4.36]} rotation={[-3.06, 0.04, 3.14]} scale={5.13} />
      </group>
    </group>
  )
}

useGLTF.preload('/model.gltf')
