/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 model.gltf
*/

import React, { useRef, useState, useEffect } from "react";
import { useGLTF, useAnimations, Gltf, useHelper } from "@react-three/drei";
import { useFrame, useLoader, useThree, Canvas  } from "@react-three/fiber";
import * as THREE from 'three';
import { AnimationMixer, BoxHelper } from "three";
import MouseSpeed from "mouse-speed";

//Saving window size
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight
};

//Mouse position related stuff
const pointer = new THREE.Vector2;

const cursor = {
  x: 0,
  y: 0,
  relX: 0,
  relY : 0
};

//Mouse speed related vars
var timestamp = null;
var lastMouseX = null;
let speedX = 0;
let calculateSpeed = true;

//calculating and storing mouse positions
window.addEventListener("mousemove", (event) => {
  cursor.x = event.clientX;
  cursor.y = event.clientY;
  cursor.relX = cursor.x - sizes.width/2;
  cursor.relY = sizes.height/2 - cursor.y;

  pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;  

  if(calculateSpeed) {
    if (timestamp === null) {
      timestamp = Date.now();
      lastMouseX = cursor.x
      return;
    }
    var now = Date.now();
    var dt =  now - timestamp;
    var dx = event.clientX - lastMouseX;
    speedX = Math.round(dx / dt * 100);

    timestamp = now;
    lastMouseX = event.clientX;
  } else { speedX = 0; }
});

//Function to map value to a range
function scale(number, inMin, inMax, outMin, outMax) {
  return ((number - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
}

//Initializing animation related variables
const mixer = new THREE.AnimationMixer();
var animIntialised = false;
let animationIsPlaying = false;
let animationState = 0;
/*
  0 > None
  1 > Tongue Out
  2 > Hair Kick
  3 > Pull Away
  4 > Dance
  5 > Face Anim
  6 > Blower
  7 > Goofy Tongue Out 
*/

//Function to set blend weights to 0 for pointer position related animations
function intialiseMovementActions(action) {
  action.play();
  action.weight = 0;
  action.blendMode = 2500;
}

//Function to add all playable animations to mixer to allow blending
function initAnims(animations, mixer, root) {
  animations.forEach((animation) => {
    mixer.clipAction(animation, root).play();
  })
  animIntialised = true;
}

//For animations that should be played once on trigger
function playActionOnce(action, origAction) {
  origAction.fadeOut(1);
  action.reset();
  action.fadeIn(1);
  action.play();
  action.setLoop(THREE.LoopOnce);  
  action.clampWhenFinished = false;
}

//For animations that should be played on loop on trigger
function playActionLoop(action, origAction) {
  origAction.fadeOut(1);
  action.reset();
  action.fadeIn(1);
  action.play();
  action.setLoop(THREE.LoopRepeat);  
  action.clampWhenFinished = false;
}  

//secondsCounter
let startSecond = new Date().getTime() / 1000;
const blowStartSecond = new Date().getTime() / 1000;
var seconds = 0;
var blowSeconds = 1;
var countSeconds = true;
var countBlowSeconds = true;
let timerToBeReset = true;
function resetTimer() {
  seconds = 0;
  startSecond = new Date().getTime() / 1000;
  countSeconds = true;
}

//Animation State logger
function logAnimationState() {
  let currentState = "None";
  switch(animationState) {
    case 0:
      currentState = "Idle";
      break;
    case 1:
      currentState = "Teeths Out";
      break;
    case 2:
      currentState = "Hair Kick";
      break;
    case 3:
      currentState = "Pulling Away";
      break;
    case 4:
      currentState = "Dancing";
      break;
    case 5:
      currentState = "Face Anims";
      break;
    case 6:
      currentState = "Blowing Air";
      break;
    case 7:
      currentState = "Goofy Tongue Out";
      break;
    default:
      currentState = "Unknown";
      break;
  }
  console.log(currentState);
}

//export function starts here
export default function Model(props) {

  console.log("Pony 0.1a");

  const group = useRef() 

  const { nodes, materials, animations } = useGLTF("/model.gltf");  

  materials.teeth.color = new THREE.Color(0x525252);
  materials.eye.color = new THREE.Color(0xdbdbdb);
  materials['horse-base'].roughness = 0.65;
  materials.braids.roughness = 0.8;

  const { actions } = useAnimations(animations, group)   

  useFrame((state, delta) => {    

    //Initializing all animations
    if(!animIntialised) {
      actions.default.play();
      initAnims(animations, mixer, actions.default.getRoot());
    } 
    intialiseMovementActions(actions.openmouth);
    intialiseMovementActions(actions.dwayne);
    
    //pony head movement tracked to pointer position
    nodes.Bonehead.rotation.z = scale(cursor.x, 0, sizes.width, -0.5, 0.5) * -1;
    nodes.Bonehead.rotation.x = scale(cursor.y, 0, sizes.width, 2.0, 3.0);

    logAnimationState();
    //interactions to play when user interacts with the pony's face
    if(pointer.x > -0.2 && pointer.x < 0.2 && !animationIsPlaying) {

      //mouth animation
      if(pointer.y < -0.5 && pointer.y > -0.8 && animationState == 0) {
        if(timerToBeReset) {
          resetTimer();
          timerToBeReset = false;
          console.log("Playing mouth animation in 2 seconds");
        }
        if(countSeconds) {
          seconds = new Date().getTime() / 1000;
          seconds -= startSecond;          
        }
        if(seconds > 2) {
          animationIsPlaying = true;
          animationState = 1;
          countSeconds = false;
          playActionOnce(actions.tonguepeep, actions.default)
          const clipLen = actions.tonguepeep.getClip().duration*1000;              
          setTimeout(function() { playActionLoop(actions.default, actions.tonguepeep);}, clipLen - 500);
          setTimeout(function() { timerToBeReset = true; animationIsPlaying = false; }, clipLen);
        }        
      }

      if(animationState == 1 && !animationIsPlaying && (pointer.y > -0.5 || pointer.y < -0.8)) {
        animationState = 0;
      }

      //face animations
      if(pointer.y > -0.5 && pointer.y < 0.35 && animationState == 0) {
        if(timerToBeReset) {
          resetTimer();
          timerToBeReset = false;
          console.log("Playing face animation in 2 seconds");
        }
        if(countSeconds) {
          seconds = new Date().getTime() / 1000;
          seconds -= startSecond;
        }
        if(seconds > 2) {
          countSeconds = false;
          animationIsPlaying = true;
          animationState = 5;
          let random = Math.round(Math.random()*10);
          let actionToDo;
          if(random%2) actionToDo = actions.headbanger;
          else actionToDo = actions.vibrator;
          playActionOnce(actionToDo, actions.default)
          const clipLen = actionToDo.getClip().duration*1000;              
          setTimeout(function() { playActionLoop(actions.default, actionToDo);}, clipLen - 1000);
          setTimeout(function() { timerToBeReset = true; animationIsPlaying = false; }, clipLen);
        }
      }

      if(animationState == 5 && !animationIsPlaying && (pointer.y < -0.5 || pointer.y > 0.35)) {
        animationState = 0; 
      }

      //hair kicking interaction
      if(pointer.y > 0.36 && pointer.y < 0.7 && animationState == 0) {
        animationIsPlaying = true;
        animationState = 2;
        playActionOnce(actions.hairkick, actions.default)
        const clipLen = actions.hairkick.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.hairkick); }, clipLen - 800);
        setTimeout(function() { animationState = 0; animationIsPlaying = false; }, clipLen);
      }
    
    }

    if (pointer.x < -0.2 || pointer.x > 0.2 && seconds!=0) {
      seconds = 0;
    }
     
    //additional interactions mapped to cursor position
    if(animationState != 1 && animationState != 7) {
      if(cursor.relX > 0 && cursor.relY > 0) {
        actions.openmouth.weight = scale(Math.min(cursor.relX, cursor.relY), 0, sizes.width/2, 0, 1)  
      } else { actions.openmouth.weight = 0; }
  
      if(cursor.relX < 0 && cursor.relY > 0) {
        actions.dwayne.weight = scale(Math.min((cursor.relX*-1), cursor.relY), 0, sizes.width/2, 0, 1)      
      } else { actions.dwayne.weight = 0; }  
    } 

    //pulling away interaction
    if(!animationIsPlaying) {
      if(pointer.x < -0.5 && pointer.y < -0.5) {
        animationIsPlaying = true;
        animationState = 3;
        playActionOnce(actions.moveaway, actions.default)
        const clipLen = actions.moveaway.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.moveaway); }, clipLen - 800);
        setTimeout(function() { animationIsPlaying = false; }, clipLen);
      }
    }            

    if (animationState == 3 && !animationIsPlaying) {
      if(pointer.x > -0.6 || pointer.y > -0.6) animationState = 0;
    }

    //tongue animation on top-left corner of screen
    if(!animationIsPlaying && animationState == 0) {
      if(pointer.x > 0.5 && pointer.y > 0.5) {
        animationIsPlaying = true;
        animationState = 7;
        playActionOnce(actions.tounguesout, actions.default)
        const clipLen = actions.tounguesout.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.tounguesout); }, clipLen - 1000);
        setTimeout(function() { animationIsPlaying = false; }, clipLen);
      }  
    }

    if (animationState == 7 && !animationIsPlaying) {
      if(pointer.x < 0.5 || pointer.y < 0.5) animationState = 0;
    }

    //dancing animation on top-right corner
    if(!animationIsPlaying) {
      if(pointer.x < -0.5 && pointer.y > 0.5) {
        animationState = 4;
        animationIsPlaying = true;
        playActionOnce(actions.shakeit, actions.default)
        const clipLen = actions.shakeit.getClip().duration*1000;              
        setTimeout(function() { playActionLoop(actions.default, actions.shakeit); }, clipLen - 1000);
        setTimeout(function() { animationIsPlaying = false; }, clipLen);
      }   
    }

    if (animationState == 4 && !animationIsPlaying) {
      if(pointer.x > -0.5 || pointer.y < 0.5) animationState = 0;
    }

    //interactions mapped to cursor speed 
    if(speedX>3000) {
      calculateSpeed = false;
      playActionOnce(actions.headknock1, actions.default)
      const clipLen = actions.headknock1.getClip().duration*1000;              
      setTimeout(function() { playActionLoop(actions.default, actions.headknock1); }, clipLen - 1000);
      setTimeout(function() { calculateSpeed = true; }, clipLen);
    }   

    //blow nose animation at random intervals
    if(countBlowSeconds && animationState == 0) {
      blowSeconds = new Date().getTime() / 1000;
      blowSeconds -= blowStartSecond;
      blowSeconds = Math.round(blowSeconds);
    }
    if (blowSeconds%11 == 0 && !animationIsPlaying) {
      animationState = 6;
      countBlowSeconds = false;
      animationIsPlaying = true;
      playActionOnce(actions.blower, actions.default)
      const clipLen = actions.blower.getClip().duration*1000;              
      setTimeout(function() { playActionLoop(actions.default, actions.blower); }, clipLen - 1000);
      setTimeout(function() { animationIsPlaying = false; countBlowSeconds = true; animationState = 0; }, clipLen);
    }
  });  

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" position={[0, -2, -15]} scale={2}>
          <primitive object={nodes.Boneneck} />
          <primitive object={nodes.Bonehead} />
          <skinnedMesh name="eyes" geometry={nodes.eyes.geometry} material={materials.eye} skeleton={nodes.eyes.skeleton} />
          <group name="pony">
            <skinnedMesh name="pony-mesh" geometry={nodes['pony-mesh'].geometry} material={materials['horse-base']} skeleton={nodes['pony-mesh'].skeleton} />
            <skinnedMesh name="pony-mesh_1" geometry={nodes['pony-mesh_1'].geometry} material={materials.braids} skeleton={nodes['pony-mesh_1'].skeleton} />
          </group>
          <skinnedMesh name="teeth" geometry={nodes.teeth.geometry} material={materials.teeth} skeleton={nodes.teeth.skeleton} />
          <skinnedMesh name="tongue" geometry={nodes.tongue.geometry} material={materials.tongue} skeleton={nodes.tongue.skeleton} />
        </group>
        <pointLight name="Point" intensity={0.1} decay={2} position={[4,0,-25]} rotation={[-Math.PI / 2, 0, 0]} />
        <pointLight name="Area002" intensity={0.1} decay={2} position={[-5,0,-30]} rotation={[-1.1, -0.29, -2.08]} scale={5.13} />
        <pointLight name="Area001" intensity={0.1} decay={2} position={[0,20,-15]} rotation={[-3.13, -0.54, -3.14]} scale={5.13} />
        <pointLight name="Area" intensity={0} decay={2} position={[1.08, 3.17, -4.36]} rotation={[-3.06, 0.04, 3.14]} scale={5.13} />
      </group>
    </group>
  )
}

useGLTF.preload('/model.gltf')
